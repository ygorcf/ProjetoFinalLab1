#ifndef _FUNCOES_JANELA_C_
#define _FUNCOES_JANELA_C_

#include <Cabecalhos/tiposDadosJanela.h>
#include <Cabecalhos/funcoesMenu.h>
#include <stdio.h>



// Objetivo: Criar uma janela
// Parametros: O endereco da string que contem o titulo da janela, a largura da	janela e 
//							a altura da janela
// Retorno: A janela criada ou NULL se ocorrer um erro
Janela criarJanela(char *tituloJanela, int largura, int altura){
	Janela jan = NULL;
  //Cria a janela
  jan = SDL_CreateWindow(tituloJanela, // Titulo da janela
													SDL_WINDOWPOS_UNDEFINED, // Posicao X na tela
													SDL_WINDOWPOS_UNDEFINED, // Posicao Y na tela
													largura, // Largura da janela, em pixels
													altura, // Altura da janela, em pixels
													SDL_WINDOW_SHOWN); // Como vai ser a janela
	
	//Verifica se ocorreu um erro ao criar a janela
	if(jan == NULL)
		salvarErro("Erro na funcao 'SDL_CreateWindow' de 'criarJanela': %s\n", 
						SDL_GetError());
  
	return jan;					
}


// Objetivo: Criar um painel
// Parametro: A janela onde ficara o painel
// Retorno: O painel criado ou NULL se ocorrer um erro
Painel criarPainel(Janela janela){
	Painel painel = NULL;
  painel = SDL_CreateRenderer(janela, // A janela onde ficara o painel
														-1, // O index do driver de renderizacao ou -1 para
																//	o primeiro driver
														SDL_RENDERER_SOFTWARE); // O tipo de rederizacao
	
	//Verifica se ocorreu um erro ao criar o painel
	if(painel == NULL)
		salvarErro("Erro na funcao 'SDL_CreateRenderer' de 'criarPainel': %s\n", 
						SDL_GetError());
	
	// Pinta o fundo do painel com a cor branca e verifica se ocorreu um erro ao 
	//	pintar o fundo
	if(alteraCorFundoPainel(painel, BRANCO) != 0){
  	salvarErro("Erro na funcao 'alteraCorFundoPainel' de 'criarPainel': %s\n", 
						SDL_GetError());
		return NULL;
	}
	
	return painel;
}



// Objetivo: Alterar a cor de fundo do painel
// Parametros: O painel que mudara a cor de fundo, a nova cor que ficara no fundo do 
//							painel
// Retorno: 0 - Se a funcao executar com sucesso
//					1 - Se ocorrer um erro
int alteraCorFundoPainel(Painel painelAlterarCor, Cor novaCor){
	// Define a cor do fundo do painel e verifica se ocorreu um erro ao definir a 
	//	cor
  if(SDL_SetRenderDrawColor(painelAlterarCor, // Painel que sera definido a cor
														novaCor.r, // Quantidade de vermelho
														novaCor.g, // Quantidade de verde
														novaCor.b, // Quantidade de azul
														novaCor.opacidade) != 0){ // Opacidade da cor
  	salvarErro("Erro na funcao 'SDL_SetRenderDrawColor' de 'alteraCorFundoPainel': %s\n", 
						SDL_GetError());
		return 1;
	}
  // Pinta o fundo do painel com a nova cor e verifica se ocorreu um erro ao 
  // pinta-lo com essa cor
  if(SDL_RenderClear(painelAlterarCor) != 0){
  	salvarErro("Erro na funcao 'SDL_RenderClear' de 'alteraCorFundoPainel': %s\n", 
						SDL_GetError());
		return 1;
	}
	
	return 0;
}



// Objetivo: Abrir uma fonte
// Parametros: O endereco de uma string que contem o local onde a fonte esta armazenada 
//							e o tamanho da fonte
// Retorno: A fonte ou NULL se ocorrer um erro
Fonte abrirFonte(char *localFonte, int tamanhoFonte){
	Fonte fonte = NULL;
	
	// Abre a fonte
	fonte = TTF_OpenFont(localFonte, // Local onde esta a fonte
												tamanhoFonte); // Tamanho da fonte
	
	// Verifica se ocorreu um erro ao abrir a fonte
	if(fonte == NULL)
		salvarErro("Erro na funcao 'TTF_OpenFont' de 'abrirFonte': %s\n", 
						TTF_GetError());
	
	return fonte;
}



// Objetivo: Transformar um texto em uma superficie
// Parametros: O endereco da string que contem o texto e a fonte do texto
// Retorno: A superficie do texto ou NULL se ocorrer um erro
Superficie textoParaSuperficie(char *texto, Fonte fonteTexto){
	Superficie superficeTexto = NULL;
	
	// Transforma o texto em uma superficie
	superficeTexto = TTF_RenderText_Solid(fonteTexto, // A fonte do texto
	                                       texto, // O texto que sera tranformado
	                                       COR_FONTE_PRINCIPAL); // A cor do texto
	
	// Verifica se ocorreu um erro ao transformar o text em superficie
	if(superficeTexto == NULL) 
		salvarErro("Erro na funcao 'TTF_RenderText_Solid' de 'textoParaSuperficie': %s\n", 
						TTF_GetError());
	
	// Limpa a memoria utilizada pela fonte
	TTF_CloseFont(fonteTexto);
	
	return superficeTexto;
}



// Objetivo: Transformar uma superficie em textura
// Parametros: O painel onde ficara a superficie e a superficie que sera transformada
// Retorno: A textura criada ou NULL se ocorrer um erro
Textura superficieParaTextura(Painel painelDestino, Superficie superficieTransformar){
	Textura novaTextura = NULL;
	
	// Cria uma textura apartir da superficie
	novaTextura = SDL_CreateTextureFromSurface(painelDestino, // O painel que ficara a textura
																							superficieTransformar); // A superficie que 
																							                        //  sera transformada
	
	// Verifica se ocorreu um erro ao criar a textura
	if(novaTextura == NULL) 
		salvarErro("Erro na funcao 'SDL_CreateTextureFromSurface' de 'superficieParaTextura': %s\n", 
						SDL_GetError());
	
	return novaTextura;
}



// Objetivo: Limpar a memoria usada pela superficie
// Parametro: A superficie a ser limpa
void limparMemSuperficie(Superficie superficieLimpar){
	SDL_FreeSurface(superficieLimpar);
}



// Objetivo: Copiar uma parte ou toda a textura para um painel
// Parametros: O painel onde ficara a textura, a textura que sera copiada para o painel 
//							e o retangulo com o tamanho que sera usado pela textura no painel
// Retorno: 0 - Se a textura foi copiada para o painel com sucesso ou o codigo do erro 
//					 que ocorreu
int copiarTexturaPainel(Painel painelDestino, Textura texturaCopiar, 
                         Retangulo retanguloTextura){
	int res = 0;
	
	// Copia a textura para o painel
	res = SDL_RenderCopy(painelDestino, // O painel onde ficara a textura
												texturaCopiar, // A textura a ser copiada
													NULL, // O tamanho que sera copiado da textura ou
																//	NULL para toda textura
													&retanguloTextura); // O tamanho que sera utilizado
	
	// Verifica se ocorreu um erro ao copiar a textura
	if(res != 0)
		salvarErro("Erro na funcao 'SDL_RenderCopyEx' de 'copiarTexturaPainel': %s\n", 
						SDL_GetError());
	
	return res;
}



// Objetivo: Atualizar um painel
// Parametro: O painel a ser atualizado
void atualizarPainel(Painel painelAtualizar){
	SDL_RenderPresent(painelAtualizar);
}



// Objetivo: Pintar no painel um texto
// Parametros: O endereco da string que contem o texto que será pintado, a posicao X e 
//              Y de onde ficara o texto, a fonte do texto e a janela onde ficara o texto
// Retorno: A estrutura Componente contendo dados do texto no painel e se ocorreu um erro
//           o atributo 'painelPertencente' da estrutura estara setado como NULL
Componente pintarTextoPainel(char *textoPintar, int posX, int posY, Fonte fonteTexto, 
															Janela janelaDestino){
	Componente componenteTexto;
	// Inicializa o 'painelPertencente' como NULL para ser uma flag de erro
	componenteTexto.painelPertencente == NULL;
	
	if(strlen(textoPintar) > 0){
		Superficie super;
		int copiadaSucesso = 0;
		// Transforma o texto em superficie
		super = textoParaSuperficie(textoPintar, fonteTexto);
		
		// Verifica se ocorreu um erro ao criar a superficie
		if(super == NULL){
			salvarErro("Erro na funcao 'textoParaSuperficie' de 'pintarTextoPainel'\n");
      return componenteTexto;
    }
		
		// Define as coordenadas da area ocupada pelo texto dentro do painel
		componenteTexto.area.x = posX;
		componenteTexto.area.y = posY;
		componenteTexto.area.h = super->h;
		componenteTexto.area.w = super->w;
		
		// Pega a superficie da janela de destino
		Superficie sJanela = SDL_GetWindowSurface(janelaDestino);
		// Copia uma superficie para outra
		SDL_BlitSurface(super, // A superficie que sera copiada
		                 NULL, // O retangulo que sera copiado da superficie ou NULL para 
		                       //  toda superficie
		                 sJanela, // A superficie de destino
		                 &componenteTexto.area); // O retangulo onde sera copiada a 
		                                         //  primeira superficie
		// Atualiza a superficie da janela
		SDL_UpdateWindowSurface(janelaDestino);
		// Limpa a memoria utilizada pelas superficies
		limparMemSuperficie(sJanela);
		limparMemSuperficie(super);
		// Garante que nao restara nada na memoria sobre as superficies
		sJanela = 0;
		super = 0;
	}
	
	// Cria um painel auxiliar e seta ele com o painel da janela
	Painel painelJanela = SDL_GetRenderer(janelaDestino);
	
	// Verifica se ocorreu erro ao receber o painel auxiliar
	if(painelJanela == NULL){
	  salvarErro("Erro na funcao 'SDL_GetRenderer' de 'pintarTextoPainel': %s\n", 
						SDL_GetError());
    return componenteTexto;
	}
	
	// Define o painel do componente do texto com o painel auxiliar
	componenteTexto.painelPertencente == painelJanela;
	
	// Limpar a memoria utilizada pelo painel auxiliar
	limparMemPainel(painelJanela);
	
	return componenteTexto;
}



// Objetivo: Criar uma nova superficie
// Parametros: A largura e a altura da superficie
// Retorno: A superficie criada ou NULL se ocorrer um erro
Superficie criarSuperficie(int largura, int altura){
	Superficie super;
	
	// Cria a superficie no formato RGB
	super = SDL_CreateRGBSurface(0, // Tipo de superficie
															 largura, // largura da superficie
															 altura, // Altura da superficie
															 32, // Quantidade de bites nas mascaras RGB
															 0, // Mascara R
															 0, // Mascara G
															 0, // Mascara B
															 0); // Mascara A
	
	// Verificar se ocorreu um erro ao criar a superficie
	if(super == NULL)	
		salvarErro("Erro na funcao 'SDL_CreateRGBSurface' de 'criarSuperficie': %s\n", 
						SDL_GetError());
	
	return super;
}



// Objetivo: Pintar toda uma superficie com uma cor
// Parametros: A superficie a ser pintada e a cor a ser pintada
// Retorno: 0 - Se a superficie foi pintada com sucesso ou o codigo de erro
int pintarSuperficie(Superficie superficiePintar, Cor corPintar){
	int ret = 0;
	
	// Pinta a superficie
	ret = SDL_FillRect(superficiePintar, // A superficie a ser pintada
											NULL, // Retangulo com as coordenadas do quadrado a ser pintado ou
														//  NULL para toda a superficie
											SDL_MapRGB( // Pega o valor inteiro da cor a ser pintada no mesmo 
																	//  formato de bits da superficie
																	superficiePintar->format, // Pega o formato de bits da 
																														//  superficie
																	corPintar.r, // Cor vermelha
																	corPintar.g, // Cor verde
																	corPintar.b)); // Cor azul
	
	// Verifica se ocorreu erro ao pintar a superficie
	if(ret != 0)
		salvarErro("Erro na funcao 'SDL_FillRect' de 'pintarSuperficie': %s\n", 
						SDL_GetError());
	
	return ret;
}



// Objetivo: Pintar um retangulo no painel
// Parametros: As coordenadas X e Y onde o retangulo sera pintado no painel, a largura e 
//							altura do retangulo, a cor do retangulo a ser pintado e o painel onde o 
//							retangulo sera pintado
// Retorno: A estrutura Componente contendo os dados do retangulo no painele se ocorreu 
//           um erro o atributo 'painelPertencente' da estrutura estara setado como NULL
Componente pintarRetanguloPainel(int posX, int posY, int largura, int altura, Cor cor, 
																	Painel painelDestino){
	Componente comp;
	// Inicializa o 'painelPertencente' como NULL para ser uma flag de erro
	comp.painelPertencente = NULL;
	
	// Define a area do retangulo
	comp.area.x = posX;
	comp.area.y = posY;
	comp.area.w = largura;
	comp.area.h = altura;
	
	// Define a cor do retangulo e verifica se ocorreu um erro ao definir essa cor
  if(SDL_SetRenderDrawColor(painelDestino, // Painel que sera pintado o retangulo
														cor.r, // Quantidade de vermelho
														cor.g, // Quantidade de verde
														cor.b, // Quantidade de azul
														cor.opacidade) != 0){ // Opacidade da cor
  	salvarErro("Erro na funcao 'SDL_SetRenderDrawColor' de 'pintarRetanguloPainel': %s\n", 
						SDL_GetError());
		return comp;
	}
	
	// Desenha o retangulo e verifica se ocorreu um erro ao desenha-lo
	if(SDL_RenderDrawRect(painelDestino, // O painel onde sera pintado o retangulo
	                       &comp.area) != 0){ // O retangulo que sera pintado
	  salvarErro("Erro na funcao 'SDL_RenderDrawRect' de 'pintarRetanguloPainel': %s\n", 
						SDL_GetError());
		return comp;
	}
	
	comp.painelPertencente = painelDestino;
	
	return comp;
}



// Objetivo: Pintar em um painel uma tabela
// Parametros: As coordenadas X e Y onde a tabela sera pintada no painel, a largura e 
//							altura da tabela, a cor da borda, a quantidade de colunas da tabela, a 
//							quantidade de linhas da tabela e o painel onde a tabela sera pintada
// Retorno: A estrutura Componente contendo os dados do retangulo no painel ou se ocorrer 
//					 um erro o atributo 'painelPertencente' da estrutura estara setado como NULL
Componente pintarTabelaPainel(int posX, int posY, int largura, int altura, Cor corBorda, 
                               int qtdColunas, int qtdLinhas, Painel painelDestino){
	Componente comp, compAux;
	int linhaAtual, colunaAtual, larguraCelula, alturaCelula, celulaW, celulaH;
	
	// Inicializa o 'painelPertencente' como NULL para ser uma flag de erro
	comp.painelPertencente = NULL;
	/*
	 *
	 *
	 *
	 *
	 *                ALTERAR BORDAS PARA FICAR APENAS COM UM PX DE LARGURA
	 *
	 *
	 *
	 *
	 *
	 */
	// Pinta um retangulo para ser a borda de fora da tabela
	comp = pintarRetanguloPainel(posX, posY, largura, altura, corBorda, painelDestino);
	
	// Verifica se ocorreu um erro ao pintar o retangulo da borda de fora da tabela
	if(comp.painelPertencente == NULL){
		salvarErro("Erro na funcao 1 'pintarRetanguloPainel' de 'pintarRetanguloCBordasPainel'\n");
		return comp;
	}
	
	// Cria um retangulo contendo as coordenadas da tabela sem a borda de fora
	Retangulo areaTabelaSBorda = {posX + larguraBorda, posY + larguraBorda, 
																 largura - (larguraBorda*2), altura - (larguraBorda*2)};
  /*
	comp.area.x = posX + larguraBorda;
	comp.area.y = posY + larguraBorda;
	comp.area.w = largura - (larguraBorda*2);
	comp.area.h = altura - (larguraBorda*2);
	*/
	
	// Calcula a largura e a altura de cada celula da tabela
	larguraCelula = areaTabelaSBorda.w / qtdColunas;
	alturaCelula = areaTabelaSBorda.h / qtdLinhas;
	
	// Ira pintar cada retangulo da tabela
	for(linhaAtual = 1; linhaAtual <= qtdLinhas; linhaAtual++){ // FOR das linhas
		for(colunaAtual = 1; colunaAtual <= qtdColunas; colunaAtual++){ // FOR das colunas
		  /*  PROBLEMA CALCULA DUAS VEZES A LARGURA E A ALTURA DAS CELULAS  */
			if(linhaAtual == qtdLinhas && (areaTabelaSBorda.y + (alturaCelula * linhaAtual) - 
					(posY + areaTabelaSBorda.h)) < 0){
				celulaH = (altura / qtdLinhas) + 
											 (-1 * (areaTabelaSBorda.y + (alturaCelula * linhaAtual) - 
											 (posY + areaTabelaSBorda.h)));
			}else{
				celulaH = areaTabelaSBorda.h / qtdLinhas;
			}
			if(colunaAtual == qtdColunas && (areaTabelaSBorda.x + (larguraCelula * colunaAtual) - 
					(posX + areaTabelaSBorda.w)) < 0){
				celulaW = (largura / qtdColunas) + 
											 (-1 * (areaTabelaSBorda.x + (larguraCelula * colunaAtual) - 
											 (posX + areaTabelaSBorda.w)));
			}else{
				celulaW = areaTabelaSBorda.w / qtdColunas;
			}
			
			// Pinta uma celula da tabela
			compAux = pintarRetanguloPainel((areaTabelaSBorda.x + (larguraCelula * 
																			 (colunaAtual -1))),
																			 (areaTabelaSBorda.y + (alturaCelula * 
																			 (linhaAtual -1))),
																			 celulaW,
																			 celulaH, 
																			 corBorda,
																			 painelDestino);
			// Verifica se ocorreu um erro ao pintar a ultima celula da tabela
			if(compAux.painelPertencente == NULL){
				salvarErro("Erro na funcao %d %d 'pintarTabelaPainel' de 'pintarRetanguloCBordasPainel'\n",
														linhaAtual, colunaAtual);
				return compAux;
			}
		}
	}
	
	comp.painelPertencente = painelDestino;
	/*
	comp.area.x = posX;
	comp.area.y = posY;
	comp.area.w = largura;
	comp.area.h = altura;
	*/
	comp.areaAux = compAux.area;
	
	return comp;	
}


/*
// Objetivo: 
Componente pintarDadoTabela(Componente tabelaDestino, int linhaTabela, int colunaTabela, 
														 char *dado, Janela janelaDestino){
	int larguraCelula, alturaCelula, posXDado, posYDado, larguraDado, alturaDado;
	Superficie superficieDado;
	Cor corTexto = COR_PRINCIPAL;
	
	printf("===============\n");
	printf("-<%d>\n", tabelaDestino);
	printf("-<%d>\n", tabelaDestino.area.x);
	printf("-<%d>\n", tabelaDestino.areaAux.x);
	printf("-<%d>\n", tabelaDestino.area.y);
	printf("-<%d>\n", tabelaDestino.areaAux.y);
	printf("-<%d>\n", tabelaDestino.area.w);
	printf("-<%d>\n", tabelaDestino.areaAux.w);
	printf("-<%d>\n", tabelaDestino.area.h);
	printf("-<%d>\n", tabelaDestino.areaAux.h);
	superficieDado = textoParaSuperficie(dado, FONTE_TEXTO_PRINCIPAL);
	larguraDado = superficieDado->w;
	alturaDado = superficieDado->h;
	limparSuperficie(superficieDado);
	larguraCelula = tabelaDestino.areaAux.w;
	printf("FOI\n");
	alturaCelula = tabelaDestino.areaAux.h;
	printf("FOI\n");
	posXDado = tabelaDestino.area.x + (larguraCelula * (colunaTabela - 1)) + 
							((larguraCelula - larguraDado) / 2);
	printf("FOI\n");
	posYDado = tabelaDestino.area.y + (alturaCelula * (linhaTabela - 1)) + 
							((alturaCelula - alturaDado) / 2);
	printf("FOI\n");
	//pintarTextoPainel()
	pintarTextoPainel(dado, posXDado, posYDado, FONTE_TEXTO_PRINCIPAL, janelaDestino);
	
}
*/


// Objetivo: Apagar a ultima letra de uma string
// Parametros: O endereco da string que contem o texto que será retirada a ultima 
//              letra, a estrutura Componente que contem informacoes sobre o texto
//              no painel
// Retorno: A estrutura Componente contendo informacoes sobre o texto no painel ou 
//           se ocorrer um erro o atributo 'painelPertencente' da estrutura estara 
//           setado como NULL
Componente retirarUltimaLetraTextoPainel(char *texto, Componente componenteTexto){
	Cor corFundo = COR_FUNDO;
	
	// Define o 'painelPertencente' como NULL para ser uma flag de erro
	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	//             ALTERAR A ESTRUTURA COMPONENTE PARA TER UMA FLAG DE ERRO
	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	// Retira o ultimo caracter da string
	rTirarCaracter(texto);
	
	// Inicializa um retangulo com as coordenadas do texto
	Retangulo rectAux = {componenteTexto.area.x,componenteTexto.area.y,
												componenteTexto.area.w,componenteTexto.area.h};
	
	// Verifica se e necessario apagar uma letra da tela
	if(strlen(texto) < 33 && strlen(texto) > 0){
	  // Se for necessario, cria a superficie do novo texto (texto sem o ultimo 
	  //  caracter)
		Superficie superAux = textoParaSuperficie(texto, FONTE_TEXTO_PRINCIPAL);
		
		// Define as novas coordenadas do texto
		rectAux.x = componenteTexto.area.x + superAux->w;
		rectAux.y = componenteTexto.area.y;
		rectAux.w = componenteTexto.area.w - superAux->w;
		rectAux.h = superAux->h;
		
		// Limpa o espaco na memoria utilizado pela superficie
		limparMemSuperficie(superAux);
	}
	
	
	// Define a cor do retangulo que apagara a ultima letra e verifica se ocorreu um 
	//  erro ao definir essa cor
  if(SDL_SetRenderDrawColor(componenteTexto.painelPertencente, // Painel que sera
                                                               //  pintado o 
                                                               //  retangulo
														corFundo.r, // Quantidade de vermelho
														corFundo.g, // Quantidade de verde
														corFundo.b, // Quantidade de azul
														corFundo.opacidade) != 0){ // Opacidade da cor
  	salvarErro("Erro na funcao 'SDL_SetRenderDrawColor' de 'retirarUltimaLetraTextoPainel': %s\n", 
						SDL_GetError());
		return componenteTexto;
	}
	
	// Prenche o retangulo no painel e verifica se ocorreu erro ao preenche-lo
	if(SDL_RenderFillRect(componenteTexto.painelPertencente, // O painel onde o retangulo 
	                                                      //  sera preenchido
	                    &rectAux) != 0){ // As coordenadas do retangulo
  	salvarErro("Erro na funcao 'SDL_RenderFillRect' de 'retirarUltimaLetraTextoPainel': %s\n", 
						SDL_GetError());
		return componenteTexto;
	}
	
	// Atualiza o painel
	atualizarPainel(componenteTexto.painelPertencente);
	
	return componenteTexto;
}



// Objetivo: Limpar todo o painel, pintando-o com a cor de fundo novamente
// Parametro: O painel que sera limpo
// Retorno: 0 - Se a funcao executar com sucesso
//					1 - Se ocorrer um erro
int limparPainel(Painel painelLimpar){
  // Pinta todo painel com a cor de fundo padrao
  if(alteraCorFundoPainel(painelLimpar, COR_FUNDO) != 0){
  	salvarErro("Erro na funcao 'alteraCorFundoPainel' de 'limparPainel'\n");
		return 1;
	}
	atualizarPainel(painelLimpar);
	return 0;
}



// Objetivo:
int verificarCliqueDentroRetangulo(Retangulo rect){
  SDL_Point posMouse;
  SDL_GetMouseState(&posMouse.x, &posMouse.y);
	if((posMouse.x <= (rect.w+rect.x) && posMouse.x >= rect.x) && 
			(posMouse.y <= (rect.h+rect.y) && posMouse.y >= rect.y)) return 1;
	return 0;
}



// Objetivo: 
int atualizarBordaComponente(Componente *compAtualizar){
	pintarRetanguloPainel(compAtualizar->area.x, compAtualizar->area.y, 300, 30, COR_PRINCIPAL, compAtualizar->painelPertencente);
	compAtualizar->painelPertencente = NULL;
}



// Objetivo: Limpar a memoria utilizada pelo painel
// Parametro: O painel a ser limpado
void limparMemPainel(Painel painelLimpar){
	SDL_DestroyRenderer(painelLimpar);
}


#endif /* _FUNCOES_JANELA_C_ */
